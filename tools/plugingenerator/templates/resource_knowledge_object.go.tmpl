// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Autogenerated code - do not modify.
// This code was generated by an automated process and should not be altered manually.
// If new types were added in object_types.json, run 'make generate' to regenerate this file.

package provider

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
    "reflect"

	"github.com/cisco-open/terraform-provider-observability/internal/api"

	"{{.TerraformBaseImportPath}}/path"
	"{{.TerraformBaseImportPath}}/resource"
	"{{.TerraformBaseImportPath}}/resource/schema"
	"{{.TerraformBaseImportPath}}/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &{{.PascalCaseObjectName}}Resource{}
var _ resource.ResourceWithImportState = &{{.PascalCaseObjectName}}Resource{}

func New{{.PascalCaseObjectName}}Resource() resource.Resource {
	return &{{.PascalCaseObjectName}}Resource{}
}

// {{.PascalCaseObjectName}}Resource defines the resource implementation.
type {{.PascalCaseObjectName}}Resource struct {
	client *api.AppdClient
}   

// {{.PascalCaseObjectName}}ResourceModel describes the resource data model.
type {{.PascalCaseObjectName}}ResourceModel struct {
    {{- range $prop := .Payload.Properties}}
    {{- $prop.Name | capFirstChar }} types.{{$prop.Type}} `tfsdk:"{{$prop.Name | camelToSnakeCase}}"`
    {{end -}}
	ObjectID  types.String `tfsdk:"object_id"`
	LayerID   types.String `tfsdk:"layer_id"`
	LayerType types.String `tfsdk:"layer_type"`
	ImportID  types.String `tfsdk:"import_id"`
	ID        types.String `tfsdk:"id"`
}

type Payload{{.PascalCaseObjectName}} struct {
    {{- range $prop := .Payload.Properties}}
    {{- $prop.Name | capFirstChar }} {{$prop.Type | toLower}} `json:"{{$prop.Name}}"`
    {{end -}}
}

func (r *{{.PascalCaseObjectName}}Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_" + "{{.SnakeCaseObjectName}}"
}

// Schema defines the schema for the resource.
func (r *{{.PascalCaseObjectName}}Resource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "{{.Payload.Description}}",
		Attributes: map[string]schema.Attribute{
            {{- range $prop := .Payload.Properties}}
            "{{$prop.Name | camelToSnakeCase}}": schema.{{$prop.Type}}Attribute{
				MarkdownDescription: "{{$prop.Description}}",
                {{- if $prop.Required}}
				Required:            {{$prop.Required}},
                {{- else}}
                Optional: true,
                {{- end}}
                {{- if $prop.Sensitive}}
                Sensitive: true,
                {{- end}}
			},
            {{end -}}
            "object_id": schema.StringAttribute{
				MarkdownDescription: "Spepcified the object ID for the particular object to get",
				Optional:            true,
			},
			"layer_id": schema.StringAttribute{
				MarkdownDescription: "Specifies the layer ID where the object resides",
				Required:            true,
			},
			"layer_type": schema.StringAttribute{
				MarkdownDescription: "Specifies the layer type where the object resides",
				Required:            true,
			},
            "import_id": schema.StringAttribute{
				MarkdownDescription: "ID used when doing import operation on an object",
				Optional:            true,
			},
            "id": schema.StringAttribute{
				MarkdownDescription: "Used to provide compatibility for testing framework",
				Computed:            true,
			},
		},
	}
}

func (r *{{.PascalCaseObjectName}}Resource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*api.AppdClient)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *api.AppdClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.client = client
}

//nolint:gocritic // Terraform framework requires the method signature to be as is
func (r *{{.PascalCaseObjectName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Debug(ctx, "Create method invoked")
	var data {{.PascalCaseObjectName}}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// issue the API call
	typeName := "{{.Fqtn}}"
	layerType := data.LayerType.ValueString()
	layerID := data.LayerID.ValueString()

    // create the payload
	jsonPayload, err := json.Marshal(Payload{{.PascalCaseObjectName}}{
        {{range $prop := .Payload.Properties}}
        {{- $prop.Name | capFirstChar }}: data.{{$prop.Name | capFirstChar}}.Value{{$prop.Type}}(),
        {{end -}}
    })

    if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to marshal type %s", typeName),
			err.Error(),
		)
		return
    }

	err = r.client.CreateObject(typeName, layerID, layerType, jsonPayload)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to Read type %s", typeName),
			err.Error(),
		)
		return
	}

	// set the placeholder value for testing purposses
	data.ID = types.StringValue("placeholder")

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Debug(ctx, "created a resource")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

//nolint:gocritic,funlen // Terraform framework requires the method signature to be as is
func (r *{{.PascalCaseObjectName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Debug(ctx, "Read method invoked")
	var data {{.PascalCaseObjectName}}ResourceModel
    var importIDTokenLength = 4

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Extract necessary fields for API call
	typeName := "{{.Fqtn}}"
	objID := data.ObjectID.ValueString()
	layerID := data.LayerID.ValueString()
	layerType := data.LayerType.ValueString()

	// Handle import scenario
	importIdentifier := data.ImportID.ValueString()
	identityFields := strings.Split(importIdentifier, "|")
	if len(identityFields) == importIDTokenLength {
		tflog.Debug(ctx, "Import scenario detected")
		tflog.Debug(ctx, "Extracting required fields from import_id")
		typeName = identityFields[0]
		objID = identityFields[1]
		layerType = identityFields[2]
		layerID = identityFields[3]
	}

	// Issue API call to fetch data
	result, err := r.client.GetObject(typeName, objID, layerID, layerType)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to Read object of type %s with id %s", typeName, objID),
			err.Error(),
		)
		return
	}

	tflog.Debug(ctx, fmt.Sprintf("api response is %s", string(result)))

	// Unmarshal API response
	var parsedResponse Payload{{.PascalCaseObjectName}}
	err = json.Unmarshal(result, &parsedResponse)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to Unmarshal response object of type %s with id %s", typeName, objID),
			err.Error(),
		)
		return
	}

	// Update the state with parsed response data for matching fields
	vData := reflect.ValueOf(&data).Elem()
	tData := vData.Type()
	vParsed := reflect.ValueOf(parsedResponse)

	for i := 0; i < tData.NumField(); i++ {
		fieldName := tData.Field(i).Name
		if parsedFieldValue := vParsed.FieldByName(fieldName); parsedFieldValue.IsValid() {
			dataFieldValue := vData.FieldByName(fieldName)
			if dataFieldValue.CanSet() && dataFieldValue.Type() == parsedFieldValue.Type() {
				dataFieldValue.Set(parsedFieldValue)
			}
		}
	}

	tflog.Debug(ctx, "read a resource")

	// Set placeholder value for testing purposes
	data.ID = types.StringValue("placeholder")

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}


//nolint:gocritic // Terraform framework requires the method signature to be as is
func (r *{{.PascalCaseObjectName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Debug(ctx, "Update method invoked")
	var data {{.PascalCaseObjectName}}ResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// issue the API call
	typeName := "{{.Fqtn}}"
	objID := data.ObjectID.ValueString()
	layerType := data.LayerType.ValueString()
	layerID := data.LayerID.ValueString()

    // create the payload
	jsonPayload, err := json.Marshal(Payload{{.PascalCaseObjectName}}{
        {{range $prop := .Payload.Properties}}
        {{- $prop.Name | capFirstChar }}: data.{{$prop.Name | capFirstChar}}.Value{{$prop.Type}}(),
        {{end -}}
    })

    if err != nil {
        resp.Diagnostics.AddError(
            fmt.Sprintf("Unable to marshal type %s", typeName),
            err.Error(),
        )
        return
    }

	err = r.client.UpdateObject(typeName, objID, layerID, layerType, jsonPayload)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to Read type %s", typeName),
			err.Error(),
		)
		return
	}

	// set the placeholder value for testing purposses
	data.ID = types.StringValue("placeholder")

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

//nolint:gocritic // Terraform framework requires the method signature to be as is
func (r *{{.PascalCaseObjectName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Debug(ctx, "Delete method invoked")
	var data {{.PascalCaseObjectName}}ResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// issue the API call
	typeName := "{{.Fqtn}}"
	objID := data.ObjectID.ValueString()
	layerID := data.LayerID.ValueString()
	layerType := data.LayerType.ValueString()

	err := r.client.DeleteObject(typeName, objID, layerID, layerType)
	if err != nil {
		resp.Diagnostics.AddError(
			fmt.Sprintf("Unable to Delete object of type %s with id %s", typeName, objID),
			err.Error(),
		)
		return
	}
}

func (r *{{.PascalCaseObjectName}}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("import_id"), req, resp)
}
